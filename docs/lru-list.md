Storage-agnostic LRU list with async/multi-key operations.

_Source: [lib/lru-list/index.js](../lib/lru-list/index.js)_

- [exports.LRUList](#exportslrulist)
- [exports.LRUEntry](#exportslruentry)
- [LRUList](#lrulist)
- [LRUEntry](#lruentrykey)
- [LRUList.prototype.set](#lrulistprototypesetkey-val-cb)
- [LRUList.prototype.shift](#lrulistprototypeshiftcb)
- [LRUList.prototype.get](#lrulistprototypegetkeys-cb)
- [LRUList.prototype.del](#lrulistprototypedelkeys-cb)
- [LRUList.prototype.delAll](#lrulistprototypedelallcb)
- [LRUList.prototype.keys](#lrulistprototypekeys)
- [LRUList.prototype.has](#lrulistprototypehaskey)
- [LRUList.prototype.saveStruct](#lrulistprototypesavestructkey-cb)
- [LRUList.prototype.restoreStruct](#lrulistprototyperestorestructkey-cb)

# exports.LRUList()

> Reference to [LRUList](#lrulist).

# exports.LRUEntry()

> Reference to [LRUEntry](#lruentrykey).

# LRUList()

> LRUList constructor.

**Configuration:**

- `{number} [limit=-1]` Max list size, by default (`-1`) unlimited
- `{function} set` Backend handler
- `{function} get` Backend handler
- `{function} del` Backend handler

**Properties:**

- `{number} size` Current key count
- `{object} tail` Reference to most recently used [LRUEntry](#lruentrykey)
- `{object} head` Reference to least recently used [LRUEntry](#lruentrykey)
- `{object} keymap` [LRUEntry](#lruentrykey) objects of the list indexed by key

# LRUEntry(key)

> LRUEntry constructor.

**Properties:**

- `{string} key`
- `{object} older` Reference to the less recently used LRUEntry
- `{object} newer` Reference to more recently used LRUEntry

**Parameters:**

- `{string} key`

# LRUList.prototype.set(key, val, cb)

> Append keys to the list's tail in object-key order. Trigger storage of the values.

- Duplicate keys are allowed by original design.
  - May produce "orphaned" entries to which the key map no longer points.
  - Then they can no longer be read/deleted, and can only be pushed out by lack of use.

**Parameters:**

- `{string | object} key` May hold key/value pairs, not just a key string.
- `{mixed} val` If `key` is an object, this will be `cb`.
- `{function} cb` If `key` is an object, this will be undefined. Receives args:
  - `{object}` `Error` or `null`

# LRUList.prototype.shift(cb)

> Remove the key at the list's head (the LRU). Trigger removal of the value.

**Parameters:**

- `{function} cb` Receives arguments:
  - `{object}` `Error` or `null`
  - `{mixed}` Shifted [LRUEntry](#lruentrykey) or undefined.

# LRUList.prototype.get(keys, cb)

> Promote the keys to the tail (MRU) in array order. Read the values from storage.

**Parameters:**

- `{string | array} keys`
- `{function} cb` Receives arguments:
  - `{object}` `Error` or `null`
  - `{mixed}` Key/value pairs or undefined.

# LRUList.prototype.del(keys, cb)

> Remove keys from the list and key map. Trigger removal of the values.

**Parameters:**

- `{string | array} keys`
- `{function} cb` Receives arguments:
  - `{object}` `Error` or `null`

# LRUList.prototype.delAll(cb)

> Delete all keys.

**Parameters:**

- `{function} cb` Receives arguments:
  - `{object}` `Error` or `null`

# LRUList.prototype.keys()

> Produce a head-to-tail ordered key list.

**Return:**

`{array}`

# LRUList.prototype.has(key)

> Check if a key exists.

**Parameters:**

- `{string} key`

**Return:**

`{boolean}`

# LRUList.prototype.saveStruct(key, cb)

> Save the key list to the storage backend.

**Parameters:**

- `{string} key`
- `{function} cb` Receives arguments:
  - `{object}` `Error` or `null`

# LRUList.prototype.restoreStruct(key, cb)

> Restore the list from the storage backend.

Reuses on [LRUList.prototype.delAll](#lrulistprototypedelallcb) and `_updateStructForPut()` to regenerate the list/map.

**Parameters:**

- `{string} key`
- `{function} cb` Receives arguments:
  - `{object}` `Error` or `null`

_&mdash;generated by [apidox](https://github.com/codeactual/apidox)&mdash;_
